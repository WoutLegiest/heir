use tfhe::boolean::prelude::*;


// pub fn fn_under_test(
//   v0: &ServerKey,
//   v1: &Vec<Ciphertext>,
//   v2: &Vec<Ciphertext>,
// ) -> Vec<Ciphertext> {
//   let v1 = v1.iter().collect();
//   let v2 = v2.iter().collect();
//   let v3 = v0.xor_packed(&v1, &v2);
//   v3
// }

use tfhe::boolean::prelude::*;


pub fn fn_under_test_fpga(
  v0: &ServerKey,
  v1: &Vec<Ciphertext>,
  v2: &Vec<Ciphertext>,
) -> Vec<Ciphertext> {
  let v3 = 7;
  let v4 = 6;
  let v5 = 5;
  let v6 = 4;
  let v7 = 3;
  let v8 = 2;
  let v9 = 1;
  let v10 = 0;
  let v11 = &v1[v10];
  let v12 = &v1[v9];
  let v13 = &v1[v8];
  let v14 = &v1[v7];
  let v15 = &v1[v6];
  let v16 = &v1[v5];
  let v17 = &v1[v4];
  let v18 = &v1[v3];
  let v19 = &v2[v10];
  let v20 = &v2[v9];
  let v21 = &v2[v8];
  let v22 = &v2[v7];
  let v23 = &v2[v6];
  let v24 = &v2[v5];
  let v25 = &v2[v4];
  let v26 = &v2[v3];
  let v27 = v0.and(v11, v19);
  let v28 = v0.xor(v12, v20);
  let v29 = vec![&v28, v12];
  let v30 = vec![&v27, v20];
  let v31_ref = v0.and_packed(&v29, &v30);
  let v31: Vec<&Ciphertext> = v31_ref.iter().collect();
  let v32 = 0;
  let v33 = v31[v32];
  let v34 = 1;
  let v35 = v31[v34];
  let v36 = vec![v13, v35];
  let v37 = vec![v21, v33];
  let v38_ref = v0.and_packed(&v36, &v37);
  let v38: Vec<&Ciphertext> = v38_ref.iter().collect();
  let v39 = 0;
  let v40 = v38[v39];
  let v41 = 1;
  let v42 = v38[v41];
  let v43 = vec![v13, v40];
  let v44 = vec![v21, v42];
  let v45_ref = v0.and_packed(&v43, &v44);
  let v45: Vec<&Ciphertext> = v45_ref.iter().collect();
  let v46 = 0;
  let v47 = v45[v46];
  let v48 = 1;
  let v49 = v45[v48];
  let v50 = vec![v47, v14];
  let v51 = vec![v49, v22];
  let v52_ref = v0.and_packed(&v50, &v51);
  let v52: Vec<&Ciphertext> = v52_ref.iter().collect();
  let v53 = 0;
  let v54 = v52[v53];
  let v55 = 1;
  let v56 = v52[v55];
  let v57 = vec![v56, v14];
  let v58 = vec![v54, v22];
  let v59_ref = v0.and_packed(&v57, &v58);
  let v59: Vec<&Ciphertext> = v59_ref.iter().collect();
  let v60 = 0;
  let v61 = v59[v60];
  let v62 = 1;
  let v63 = v59[v62];
  let v64 = vec![v15, v63];
  let v65 = vec![v23, v61];
  let v66_ref = v0.and_packed(&v64, &v65);
  let v66: Vec<&Ciphertext> = v66_ref.iter().collect();
  let v67 = 0;
  let v68 = v66[v67];
  let v69 = 1;
  let v70 = v66[v69];
  let v71 = vec![v15, v68];
  let v72 = vec![v23, v70];
  let v73_ref = v0.and_packed(&v71, &v72);
  let v73: Vec<&Ciphertext> = v73_ref.iter().collect();
  let v74 = 0;
  let v75 = v73[v74];
  let v76 = 1;
  let v77 = v73[v76];
  let v78 = vec![v16, v75];
  let v79 = vec![v24, v77];
  let v80_ref = v0.and_packed(&v78, &v79);
  let v80: Vec<&Ciphertext> = v80_ref.iter().collect();
  let v81 = 0;
  let v82 = v80[v81];
  let v83 = 1;
  let v84 = v80[v83];
  let v85 = vec![v16, v82];
  let v86 = vec![v24, v84];
  let v87_ref = v0.and_packed(&v85, &v86);
  let v87: Vec<&Ciphertext> = v87_ref.iter().collect();
  let v88 = 0;
  let v89 = v87[v88];
  let v90 = 1;
  let v91 = v87[v90];
  let v92 = 0;
  let v93 = 1;
  let v94 = 2;
  let v95 = 3;
  let v96 = 4;
  let v97 = 5;
  let v98 = 6;
  let v99 = 7;
  let v100 = vec![v89, v17];
  let v101 = vec![v91, v25];
  let v102_ref = v0.and_packed(&v100, &v101);
  let v102: Vec<&Ciphertext> = v102_ref.iter().collect();
  let v103 = 0;
  let v104 = v102[v103];
  let v105 = 1;
  let v106 = v102[v105];
  let v107 = vec![v106, v17];
  let v108 = vec![v104, v25];
  let v109_ref = v0.and_packed(&v107, &v108);
  let v109: Vec<&Ciphertext> = v109_ref.iter().collect();
  let v110 = 0;
  let v111 = v109[v110];
  let v112 = 1;
  let v113 = v109[v112];
  let v114 = vec![v18, v113];
  let v115 = vec![v26, v111];
  let v116_ref = v0.and_packed(&v114, &v115);
  let v116: Vec<&Ciphertext> = v116_ref.iter().collect();
  let v117 = 0;
  let v118 = v116[v117];
  let v119 = 1;
  let v120 = v116[v119];
  let v121 = vec![v118, v18];
  let v122 = vec![v120, v26];
  let v123_ref = v0.and_packed(&v121, &v122);
  let v123: Vec<&Ciphertext> = v123_ref.iter().collect();
  let v124 = 0;
  let v125 = v123[v124];
  let v126 = 1;
  let v127 = v123[v126];
  let v128 = vec![&v28, v118, v40, v68, v106, v56, v11, v82];
  let v129 = vec![&v27, v120, v42, v70, v104, v54, v19, v84];
  let v130_ref = v0.and_packed(&v128, &v129);
  let v130: Vec<&Ciphertext> = v130_ref.iter().collect();
  let v131 = v130_ref[v92].clone();
  let v132 = v130_ref[v93].clone();
  let v133 = v130_ref[v94].clone();
  let v134 = v130_ref[v95].clone();
  let v135 = v130_ref[v96].clone();
  let v136 = v130_ref[v97].clone();
  let v137 = v130_ref[v98].clone();
  let v138 = v130_ref[v99].clone();
  let v139 = vec![v132, v135, v138, v134, v136, v133, v131, v137];
  v139
}

// use tfhe::boolean::prelude::*;

pub fn fn_under_test(
  v0: &ServerKey,
  v1: &Vec<Ciphertext>,
  v2: &Vec<Ciphertext>,
) -> Vec<Ciphertext> {
  let v3 = 7;
  let v4 = 6;
  let v5 = 5;
  let v6 = 4;
  let v7 = 3;
  let v8 = 2;
  let v9 = 1;
  let v10 = 0;
  let v11 = vec![&v1[0]];
  let v12 = vec![&v1[1]];
  let v13 = vec![&v1[2]];
  let v14 = vec![&v1[3]];
  let v15 = vec![&v1[4]];
  let v16 = vec![&v1[5]];
  let v17 = vec![&v1[6]];
  let v18 = vec![&v1[7]];
  let v19 = vec![&v2[0]];
  let v20 = vec![&v2[1]];
  let v21 = vec![&v2[2]];
  let v22 = vec![&v2[3]];
  let v23 = vec![&v2[4]];
  let v24 = vec![&v2[5]];
  let v25 = vec![&v2[6]];
  let v26 = vec![&v2[7]];
  let v27_ref = v0.xor_packed(&v11, &v19);
  let v27: Vec<&Ciphertext> = v27_ref.iter().collect();
  let v28_ref = v0.and_packed(&v11, &v19);
  let v28: Vec<&Ciphertext> = v28_ref.iter().collect();
  let v29_ref = v0.xor_packed(&v12, &v20);
  let v29: Vec<&Ciphertext> = v29_ref.iter().collect();
  let v30_ref = v0.and_packed(&v12, &v20);
  let v30: Vec<&Ciphertext> = v30_ref.iter().collect();
  let v31_ref = v0.and_packed(&v29, &v28);
  let v31: Vec<&Ciphertext> = v31_ref.iter().collect();
  let v32_ref = v0.xor_packed(&v29, &v28);
  let v32: Vec<&Ciphertext> = v32_ref.iter().collect();
  let v33_ref = v0.xor_packed(&v30, &v31);
  let v33: Vec<&Ciphertext> = v33_ref.iter().collect();
  let v34_ref = v0.xor_packed(&v13, &v21);
  let v34: Vec<&Ciphertext> = v34_ref.iter().collect();
  let v35_ref = v0.and_packed(&v13, &v21);
  let v35: Vec<&Ciphertext> = v35_ref.iter().collect();
  let v36_ref = v0.and_packed(&v34, &v33);
  let v36: Vec<&Ciphertext> = v36_ref.iter().collect();
  let v37_ref = v0.xor_packed(&v34, &v33);
  let v37: Vec<&Ciphertext> = v37_ref.iter().collect();
  let v38_ref = v0.xor_packed(&v35, &v36);
  let v38: Vec<&Ciphertext> = v38_ref.iter().collect();
  let v39_ref = v0.xor_packed(&v14, &v22);
  let v39: Vec<&Ciphertext> = v39_ref.iter().collect();
  let v40_ref = v0.and_packed(&v14, &v22);
  let v40: Vec<&Ciphertext> = v40_ref.iter().collect();
  let v41_ref = v0.and_packed(&v39, &v38);
  let v41: Vec<&Ciphertext> = v41_ref.iter().collect();
  let v42_ref = v0.xor_packed(&v39, &v38);
  let v42: Vec<&Ciphertext> = v42_ref.iter().collect();
  let v43_ref = v0.xor_packed(&v40, &v41);
  let v43: Vec<&Ciphertext> = v43_ref.iter().collect();
  let v44_ref = v0.xor_packed(&v15, &v23);
  let v44: Vec<&Ciphertext> = v44_ref.iter().collect();
  let v45_ref = v0.and_packed(&v15, &v23);
  let v45: Vec<&Ciphertext> = v45_ref.iter().collect();
  let v46_ref = v0.and_packed(&v44, &v43);
  let v46: Vec<&Ciphertext> = v46_ref.iter().collect();
  let v47_ref = v0.xor_packed(&v44, &v43);
  let v47: Vec<&Ciphertext> = v47_ref.iter().collect();
  let v48_ref = v0.xor_packed(&v45, &v46);
  let v48: Vec<&Ciphertext> = v48_ref.iter().collect();
  let v49_ref = v0.xor_packed(&v16, &v24);
  let v49: Vec<&Ciphertext> = v49_ref.iter().collect();
  let v50_ref = v0.and_packed(&v16, &v24);
  let v50: Vec<&Ciphertext> = v50_ref.iter().collect();
  let v51_ref = v0.and_packed(&v49, &v48);
  let v51: Vec<&Ciphertext> = v51_ref.iter().collect();
  let v52_ref = v0.xor_packed(&v49, &v48);
  let v52: Vec<&Ciphertext> = v52_ref.iter().collect();
  let v53_ref = v0.xor_packed(&v50, &v51);
  let v53: Vec<&Ciphertext> = v53_ref.iter().collect();
  let v54_ref = v0.xor_packed(&v17, &v25);
  let v54: Vec<&Ciphertext> = v54_ref.iter().collect();
  let v55_ref = v0.and_packed(&v17, &v25);
  let v55: Vec<&Ciphertext> = v55_ref.iter().collect();
  let v56_ref = v0.and_packed(&v54, &v53);
  let v56: Vec<&Ciphertext> = v56_ref.iter().collect();
  let v57_ref = v0.xor_packed(&v54, &v53);
  let v57: Vec<&Ciphertext> = v57_ref.iter().collect();
  let v58_ref = v0.xor_packed(&v55, &v56);
  let v58: Vec<&Ciphertext> = v58_ref.iter().collect();
  let v59_ref = v0.xor_packed(&v18, &v26);
  let v59: Vec<&Ciphertext> = v59_ref.iter().collect();
  let v60_ref = v0.xor_packed(&v59, &v58);
  let v60: Vec<&Ciphertext> = v60_ref.iter().collect();
  let mut v61: Vec<Ciphertext> = vec![];
  v61.extend(v60_ref);
  v61.extend(v57_ref);
  v61.extend(v52_ref);
  v61.extend(v47_ref);
  v61.extend(v42_ref);
  v61.extend(v37_ref);
  v61.extend(v32_ref);
  v61.extend(v27_ref);
  v61
}


pub fn add_bool(
  v0: &ServerKey,
  v1: &Vec<Ciphertext>,
  v2: &Vec<Ciphertext>,
) -> Vec<Ciphertext> {
  let v3 = 7;
  let v4 = 6;
  let v5 = 5;
  let v6 = 4;
  let v7 = 3;
  let v8 = 2;
  let v9 = 1;
  let v10 = 0;
  let v11 = &v1[v10];
  let v12 = &v1[v9];
  let v13 = &v1[v8];
  let v14 = &v1[v7];
  let v15 = &v1[v6];
  let v16 = &v1[v5];
  let v17 = &v1[v4];
  let v18 = &v1[v3];
  let v19 = &v2[v10];
  let v20 = &v2[v9];
  let v21 = &v2[v8];
  let v22 = &v2[v7];
  let v23 = &v2[v6];
  let v24 = &v2[v5];
  let v25 = &v2[v4];
  let v26 = &v2[v3];
  let v27 = v0.and(v11, v19);
  let v28 = v0.xor(v12, v20);
  let v29 = vec![v12, &v28];
  let v30 = vec![v20, &v27];
  let v31_ref = v0.and_packed(&v29, &v30);
  let v31: Vec<&Ciphertext> = v31_ref.iter().collect();
  let v32 = &v31[v10];
  let v33 = &v31[v9];
  let v34 = vec![v32, v13];
  let v35 = vec![v33, v21];
  let v36_ref = v0.and_packed(&v34, &v35);
  let v36: Vec<&Ciphertext> = v36_ref.iter().collect();
  let v37 = &v36[v10];
  let v38 = &v36[v9];
  let v39 = vec![v13, v38];
  let v40 = vec![v21, v37];
  let v41_ref = v0.and_packed(&v39, &v40);
  let v41: Vec<&Ciphertext> = v41_ref.iter().collect();
  let v42 = &v41[v10];
  let v43 = &v41[v9];
  let v44 = vec![v42, v14];
  let v45 = vec![v43, v22];
  let v46_ref = v0.and_packed(&v44, &v45);
  let v46: Vec<&Ciphertext> = v46_ref.iter().collect();
  let v47 = &v46[v10];
  let v48 = &v46[v9];
  let v49 = vec![v48, v14];
  let v50 = vec![v47, v22];
  let v51_ref = v0.and_packed(&v49, &v50);
  let v51: Vec<&Ciphertext> = v51_ref.iter().collect();
  let v52 = &v51[v10];
  let v53 = &v51[v9];
  let v54 = vec![v53, v15];
  let v55 = vec![v52, v23];
  let v56_ref = v0.and_packed(&v54, &v55);
  let v56: Vec<&Ciphertext> = v56_ref.iter().collect();
  let v57 = &v56[v10];
  let v58 = &v56[v9];
  let v59 = vec![v58, v15];
  let v60 = vec![v57, v23];
  let v61_ref = v0.and_packed(&v59, &v60);
  let v61: Vec<&Ciphertext> = v61_ref.iter().collect();
  let v62 = &v61[v10];
  let v63 = &v61[v9];
  let v64 = vec![v63, v16];
  let v65 = vec![v62, v24];
  let v66_ref = v0.and_packed(&v64, &v65);
  let v66: Vec<&Ciphertext> = v66_ref.iter().collect();
  let v67 = &v66[v10];
  let v68 = &v66[v9];
  let v69 = vec![v16, v68];
  let v70 = vec![v24, v67];
  let v71_ref = v0.and_packed(&v69, &v70);
  let v71: Vec<&Ciphertext> = v71_ref.iter().collect();
  let v72 = &v71[v10];
  let v73 = &v71[v9];
  let v74 = vec![v17, v72];
  let v75 = vec![v25, v73];
  let v76_ref = v0.and_packed(&v74, &v75);
  let v76: Vec<&Ciphertext> = v76_ref.iter().collect();
  let v77 = &v76[v10];
  let v78 = &v76[v9];
  let v79 = vec![v77, v17];
  let v80 = vec![v78, v25];
  let v81_ref = v0.and_packed(&v79, &v80);
  let v81: Vec<&Ciphertext> = v81_ref.iter().collect();
  let v82 = &v81[v10];
  let v83 = &v81[v9];
  let v84 = vec![v18, v83];
  let v85 = vec![v26, v82];
  let v86_ref = v0.and_packed(&v84, &v85);
  let v86: Vec<&Ciphertext> = v86_ref.iter().collect();
  let v87 = &v86[v10];
  let v88 = &v86[v9];
  let v89 = vec![v18, v87];
  let v90 = vec![v26, v88];
  let v91_ref = v0.and_packed(&v89, &v90);
  let v91: Vec<&Ciphertext> = v91_ref.iter().collect();
  let v92 = vec![v68, v58, v48, v38, v28, v87, v77, v11];
  let v93 = vec![v67, v57, v47, v37, v27, v88, v78, v19];
  let v94_ref = v0.and_packed(&v92, &v93);
  let v94: Vec<&Ciphertext> = v94_ref.iter().collect();
  let v95 = &v94[v10];
  let v96 = &v94[v9];
  let v97 = &v94[v8];
  let v98 = &v94[v7];
  let v99 = &v94[v6];
  let v100 = &v94[v5];
  let v101 = &v94[v4];
  let v102 = &v94[v3];
  let v103 = vec![v100, v101, v95, v96, v97, v98, v99, v102];
  v103
}

pub fn fn_under_testtt(
  v0: &ServerKey,
  v1: &Vec<Ciphertext>,
  v2: &Vec<Ciphertext>,
) -> Vec<Ciphertext> {
  let v3 = 7;
  let v4 = 6;
  let v5 = 5;
  let v6 = 4;
  let v7 = 3;
  let v8 = 2;
  let v9 = 1;
  let v10 = 0;
  let v11 = v1[v10];
  let v12 = v1[v9];
  let v13 = v1[v8];
  let v14 = v1[v7];
  let v15 = v1[v6];
  let v16 = v1[v5];
  let v17 = v1[v4];
  let v18 = v1[v3];
  let v19 = v2[v10];
  let v20 = v2[v9];
  let v21 = v2[v8];
  let v22 = v2[v7];
  let v23 = v2[v6];
  let v24 = v2[v5];
  let v25 = v2[v4];
  let v26 = v2[v3];
  let v27 = v0.xor(&v11, &v19);
  let v28 = v0.and(&v11, &v19);
  let v29 = v0.xor(&v12, &v20);
  let v30 = v0.and(&v12, &v20);
  let v31 = v0.and(&v29, &v28);
  let v32 = v0.xor(&v29, &v28);
  let v33 = v0.xor(&v30, &v31);
  let v34 = v0.xor(&v13, &v21);
  let v35 = v0.and(&v13, &v21);
  let v36 = v0.and(&v34, &v33);
  let v37 = v0.xor(&v34, &v33);
  let v38 = v0.xor(&v35, &v36);
  let v39 = v0.xor(&v14, &v22);
  let v40 = v0.and(&v14, &v22);
  let v41 = v0.and(&v39, &v38);
  let v42 = v0.xor(&v39, &v38);
  let v43 = v0.xor(&v40, &v41);
  let v44 = v0.xor(&v15, &v23);
  let v45 = v0.and(&v15, &v23);
  let v46 = v0.and(&v44, &v43);
  let v47 = v0.xor(&v44, &v43);
  let v48 = v0.xor(&v45, &v46);
  let v49 = v0.xor(&v16, &v24);
  let v50 = v0.and(&v16, &v24);
  let v51 = v0.and(&v49, &v48);
  let v52 = v0.xor(&v49, &v48);
  let v53 = v0.xor(&v50, &v51);
  let v54 = v0.xor(&v17, &v25);
  let v55 = v0.and(&v17, &v25);
  let v56 = v0.and(&v54, &v53);
  let v57 = v0.xor(&v54, &v53);
  let v58 = v0.xor(&v55, &v56);
  let v59 = v0.xor(&v18, &v26);
  let v60 = v0.xor(&v59, &v58);
  let v61 = vec![v60, v57, v52, v47, v42, v37, v32, v27];
  v61
}